import { useState, useCallback, useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { GenerationRow } from '@/types/shots';

export interface ShotGeneration {
  id: string;
  shot_id: string;
  generation_id: string;
  position: number;
  timeline_frame?: number;
  pair_prompt?: string | null;
  pair_negative_prompt?: string | null;
  metadata?: PositionMetadata;
  generation?: {
    id: string;
    location?: string;
    type?: string;
    created_at: string;
  };
}

export interface PositionMetadata {
  frame_spacing?: number;
  is_keyframe?: boolean;
  locked?: boolean;
  context_frames?: number;
  user_positioned?: boolean;
  created_by_mode?: 'timeline' | 'batch';
  auto_initialized?: boolean;
}

const DEFAULT_FRAME_SPACING = 60;

/**
 * Enhanced hook for managing shot positions with unified timeline and batch support
 */
export const useEnhancedShotPositions = (shotId: string | null) => {
  const [shotGenerations, setShotGenerations] = useState<ShotGeneration[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [isPersistingPositions, setIsPersistingPositions] = useState(false);
  const queryClient = useQueryClient();
  const [error, setError] = useState<string | null>(null);

  // Load all shot_generations data for the shot
  const loadPositions = useCallback(async (opts?: { silent?: boolean; reason?: 'shot_change' | 'invalidation' | 'reorder' }) => {
    console.log('[PositionResetDebug] üì• LOAD POSITIONS CALLED:', {
      shotId: shotId?.substring(0, 8) || 'null',
      reason: opts?.reason || 'unknown',
      silent: opts?.silent || false,
      stackTrace: new Error().stack?.split('\n').slice(1, 5),
      timestamp: new Date().toISOString()
    });
    
    if (!shotId) {
      setShotGenerations([]);
      setIsInitialLoad(false);
      return;
    }

    // Determine if we should show loading based on context
    // If silent is true, only show loading if it's the initial load or no data exists
    const shouldShowLoading = !opts?.silent && (
      isInitialLoad ||  // Always show loading for initial load
      (opts?.reason !== 'reorder' && shotGenerations.length === 0)  // Show loading if no data exists (but not for reorder operations)
    );

    if (shouldShowLoading) {
      setIsLoading(true);
    }
    setError(null);

    try {
      const { data, error: fetchError } = await supabase
        .from('shot_generations')
        .select(`
          id,
          shot_id,
          generation_id,
          position,
          timeline_frame,
          pair_prompt,
          pair_negative_prompt,
          metadata,
          generation:generations(
            id,
            location,
            type,
            created_at
          )
        `)
        .eq('shot_id', shotId)
        .order('position', { ascending: true });

      if (fetchError) throw fetchError;

      setShotGenerations(prev => {
        console.log('[PositionResetDebug] üìä SETTING SHOT GENERATIONS:', {
          shotId: shotId.substring(0, 8),
          reason: opts?.reason || 'unknown',
          silent: opts?.silent || false,
          prevCount: prev.length,
          newCount: data?.length || 0,
          newData: (data || []).map(sg => ({
            id: sg.generation_id.substring(0, 8),
            position: sg.position,
            timeline_frame: sg.timeline_frame
          })),
          timestamp: new Date().toISOString()
        });
        
        return data || [];
      });
      
      console.log('[PositionResetDebug] ‚úÖ Loaded positions:', {
        shotId: shotId.substring(0, 8),
        recordCount: data?.length || 0,
        records: data?.map(sg => ({
          generationId: sg.generation_id?.substring(0, 8),
          position: sg.position,
          timelineFrame: sg.timeline_frame
        })),
        timestamp: new Date().toISOString()
      });

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load shot positions';
      setError(errorMessage);
      console.error('[useEnhancedShotPositions] Load error:', err);
    } finally {
      if (shouldShowLoading) {
        setIsLoading(false);
      }
      setIsInitialLoad(false);
    }
  }, [shotId, isInitialLoad, shotGenerations.length]);

  // Auto-load on shotId change
  useEffect(() => {
    loadPositions({ reason: 'shot_change' });
  }, [loadPositions]);

  // Listen for query invalidations that should trigger a reload
  useEffect(() => {
    if (!shotId) return;

    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event.type === 'updated' && event.query.state.isInvalidated) {
        const queryKey = event.query.queryKey;
        
        // Check if this invalidation affects our shot data
        const shouldReload = (
          // Direct shot-specific invalidation (used by duplicate mutation)
          (queryKey[0] === 'unified-generations' && queryKey[1] === 'shot' && queryKey[2] === shotId) ||
          // Shots context invalidation (affects ShotsPane)
          (queryKey[0] === 'shots' && queryKey.includes(shotId)) ||
          // Unpositioned count invalidation
          (queryKey[0] === 'unpositioned-count' && queryKey[1] === shotId)
        );

        if (shouldReload) {
          // Skip reload if we're currently persisting positions to avoid conflicts
          if (isPersistingPositions) {
            console.log('[PositionResetDebug] ‚è∏Ô∏è Skipping query invalidation reload - positions being persisted:', {
              shotId: shotId.substring(0, 8),
              invalidatedQueryKey: queryKey,
              timestamp: new Date().toISOString()
            });
            return;
          }
          
          console.log('[PositionResetDebug] üîÑ Query invalidation detected, reloading positions:', {
            shotId: shotId.substring(0, 8),
            invalidatedQueryKey: queryKey,
            timestamp: new Date().toISOString(),
            stackTrace: new Error().stack?.split('\n').slice(1, 4)
          });
          loadPositions({ reason: 'invalidation' });
        }
      }
    });

    return unsubscribe;
  }, [shotId, queryClient, loadPositions, isPersistingPositions]);

  // Get positions formatted for specific mode
  const getPositionsForMode = useCallback((mode: 'batch' | 'timeline'): Map<string, number> => {
    const positions = new Map<string, number>();
    
    shotGenerations.forEach(sg => {
      if (mode === 'timeline') {
        // Use timeline_frame if available, fallback to calculated frame
        const frame = sg.timeline_frame ?? (sg.position * DEFAULT_FRAME_SPACING);
        positions.set(sg.generation_id, frame);
      } else {
        // Batch mode uses sequential position
        positions.set(sg.generation_id, sg.position);
      }
    });
    
    return positions;
  }, [shotGenerations]);

  // Get images sorted by mode (excludes videos like original system)
  const getImagesForMode = useCallback((mode: 'batch' | 'timeline'): GenerationRow[] => {
    const images = shotGenerations
      .filter(sg => sg.generation)
      .map(sg => ({
        id: sg.generation_id,
        shotImageEntryId: sg.id,
        imageUrl: sg.generation?.location,
        thumbUrl: sg.generation?.location,
        location: sg.generation?.location,
        type: sg.generation?.type,
        createdAt: sg.generation?.created_at,
        position: sg.position,
        timeline_frame: sg.timeline_frame,
        metadata: sg.metadata
      } as GenerationRow & { position: number; timeline_frame?: number }))
      .filter(img => {
        // EXACT same video detection as original ShotEditor/ShotsPane logic
        const isVideo = img.type === 'video' ||
                       img.type === 'video_travel_output' ||
                       (img.location && img.location.endsWith('.mp4')) ||
                       (img.imageUrl && img.imageUrl.endsWith('.mp4'));
        
        if (isVideo) {
          console.log('[PositionSystemDebug] üé¨ Filtering out video from shot editor:', {
            shotId: shotId?.substring(0, 8),
            generationId: img.id.substring(0, 8),
            type: img.type,
            location: img.location?.substring(0, 20) + '...'
          });
        }
        
        return !isVideo; // Exclude videos, just like original system
      });

    // Log filtering summary
    const originalCount = shotGenerations.filter(sg => sg.generation).length;
    const filteredCount = images.length;
    if (originalCount > filteredCount) {
      console.log('[PositionSystemDebug] üìä Video filtering summary:', {
        shotId: shotId?.substring(0, 8),
        mode,
        originalCount,
        filteredCount,
        videosFiltered: originalCount - filteredCount
      });
    }

    if (mode === 'timeline') {
      // Sort by timeline_frame, fallback to calculated frame
      return images.sort((a, b) => {
        const frameA = a.timeline_frame ?? (a.position * DEFAULT_FRAME_SPACING);
        const frameB = b.timeline_frame ?? (b.position * DEFAULT_FRAME_SPACING);
        return frameA - frameB;
      });
    } else {
      // Sort by sequential position
      return images.sort((a, b) => a.position - b.position);
    }
  }, [shotGenerations]);

  // Exchange positions between two items
  const exchangePositions = useCallback(async (generationIdA: string, generationIdB: string) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping position exchange - no shot ID provided');
      return;
    }

    // Get current positions before exchange for logging
    const itemA = shotGenerations.find(sg => sg.generation_id === generationIdA);
    const itemB = shotGenerations.find(sg => sg.generation_id === generationIdB);

    const beforeState = {
      itemA: itemA ? {
        id: generationIdA.substring(0, 8),
        position: itemA.position,
        timelineFrame: itemA.timeline_frame
      } : null,
      itemB: itemB ? {
        id: generationIdB.substring(0, 8),
        position: itemB.position,
        timelineFrame: itemB.timeline_frame
      } : null
    };

    console.log('[PositionSystemDebug] üîÑ STARTING position exchange:', {
      shotId: shotId.substring(0, 8),
      before: beforeState,
      timestamp: new Date().toISOString()
    });

    try {
      const { error } = await supabase.rpc('exchange_shot_positions', {
        p_shot_id: shotId,
        p_generation_id_a: generationIdA,
        p_generation_id_b: generationIdB
      });

      if (error) throw error;

      // Reload positions to reflect changes
      await loadPositions({ reason: 'reorder' });

      // Get positions after exchange for verification logging
      const updatedGenerations = await supabase
        .from('shot_generations')
        .select('generation_id, position, timeline_frame')
        .eq('shot_id', shotId)
        .in('generation_id', [generationIdA, generationIdB]);

      const afterState = {
        itemA: updatedGenerations.data?.find(sg => sg.generation_id === generationIdA),
        itemB: updatedGenerations.data?.find(sg => sg.generation_id === generationIdB)
      };

      console.log('[PositionSystemDebug] ‚úÖ COMPLETED position exchange:', {
        shotId: shotId.substring(0, 8),
        after: {
          itemA: afterState.itemA ? {
            id: generationIdA.substring(0, 8),
            position: afterState.itemA.position,
            timelineFrame: afterState.itemA.timeline_frame
          } : null,
          itemB: afterState.itemB ? {
            id: generationIdB.substring(0, 8),
            position: afterState.itemB.position,
            timelineFrame: afterState.itemB.timeline_frame
          } : null
        },
        exchangeVerified: beforeState.itemA && afterState.itemA && beforeState.itemB && afterState.itemB
          ? (beforeState.itemA.position === afterState.itemB?.position && 
             beforeState.itemB.position === afterState.itemA?.position &&
             beforeState.itemA.timelineFrame === afterState.itemB?.timeline_frame &&
             beforeState.itemB.timelineFrame === afterState.itemA?.timeline_frame)
          : false,
        timestamp: new Date().toISOString()
      });
      
      // Position exchange completed successfully - no toast needed for smooth UX
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to exchange positions';
      console.error('[PositionSystemDebug] ‚ùå FAILED position exchange:', {
        shotId: shotId.substring(0, 8),
        before: beforeState,
        error: errorMessage,
        fullError: err,
        timestamp: new Date().toISOString()
      });
      toast.error(`Failed to exchange positions: ${errorMessage}`);
      throw err;
    }
  }, [shotId, shotGenerations, loadPositions]);

  // Exchange positions without reloading (for batch operations)
  const exchangePositionsNoReload = useCallback(async (generationIdA: string, generationIdB: string) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping position exchange (no reload) - no shot ID provided');
      return;
    }

    try {
      const { error } = await supabase.rpc('exchange_shot_positions', {
        p_shot_id: shotId,
        p_generation_id_a: generationIdA,
        p_generation_id_b: generationIdB
      });

      if (error) throw error;

      // No position reload - caller will handle this
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to exchange positions';
      console.error('[useEnhancedShotPositions] ‚ùå Exchange error (no reload):', err);
      throw err;
    }
  }, [shotId]);

  // Batch exchange positions - performs multiple exchanges then reloads once
  const batchExchangePositions = useCallback(async (exchanges: Array<{ generationIdA: string; generationIdB: string }>) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping batch position exchange - no shot ID provided');
      return;
    }

    if (exchanges.length === 0) {
      return;
    }

    console.log('[useEnhancedShotPositions] Batch exchange starting:', {
      shotId: shotId.substring(0, 8),
      exchangeCount: exchanges.length,
      exchanges: exchanges.map(ex => ({
        idA: ex.generationIdA.substring(0, 8),
        idB: ex.generationIdB.substring(0, 8)
      }))
    });

    // [TimelineItemMoveSummary] - Log batch position exchanges
    const positionsBefore = shotGenerations
      .sort((a, b) => a.position - b.position)
      .map((gen, index) => ({
        id: gen.generation_id.slice(-8),
        shotGenId: gen.id.slice(-8),
        position: gen.position,
        timelineFrame: gen.timeline_frame
      }));

    try {
      // Perform all exchanges without reloading positions each time
      for (const exchange of exchanges) {
        await exchangePositionsNoReload(exchange.generationIdA, exchange.generationIdB);
      }

      console.log('[useEnhancedShotPositions] ‚úÖ All exchanges completed, reloading positions once');

      // Single reload after all exchanges are done
      await loadPositions({ reason: 'reorder' });

      // Log the batch exchange summary after reload
      const positionsAfter = shotGenerations
        .sort((a, b) => a.position - b.position)
        .map((gen, index) => ({
          id: gen.generation_id.slice(-8),
          shotGenId: gen.id.slice(-8),
          position: gen.position,
          timelineFrame: gen.timeline_frame
        }));

      console.log('[TimelineItemMoveSummary] Timeline batch exchange completed', {
        moveType: 'batch_exchange',
        positionsBefore,
        positionsAfter,
        attemptedMove: {
          exchangeCount: exchanges.length,
          exchanges: exchanges.map(ex => ({
            idA: ex.generationIdA.slice(-8),
            idB: ex.generationIdB.slice(-8)
          }))
        },
        metadata: {
          shotId: shotId.substring(0, 8),
          totalItems: shotGenerations.length,
          timestamp: new Date().toISOString()
        }
      });

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to batch exchange positions';
      console.error('[useEnhancedShotPositions] ‚ùå Batch exchange error:', err);
      toast.error(`Failed to reorder items: ${errorMessage}`);
      throw err;
    }
  }, [shotId, loadPositions, exchangePositionsNoReload, shotGenerations]);

  // Delete item and its positions by shot_generations.id (not generation_id to avoid deleting duplicates)
  const deleteItem = useCallback(async (shotGenerationId: string) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping item deletion - no shot ID provided');
      return;
    }

    console.log('[PositionSystemDebug] üóëÔ∏è Deleting specific shot generation record:', {
      shotId: shotId.substring(0, 8),
      shotGenerationId: shotGenerationId.substring(0, 8)
    });

    try {
      const { error } = await supabase
        .from('shot_generations')
        .delete()
        .eq('id', shotGenerationId)
        .eq('shot_id', shotId); // Extra safety check

      if (error) throw error;

      // Reload positions to reflect changes
      await loadPositions({ reason: 'reorder' });
      
      // Item deletion completed successfully - no toast needed for smooth UX
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete item';
      console.error('[PositionSystemDebug] ‚ùå Delete error:', err);
      toast.error(`Failed to delete item: ${errorMessage}`);
      throw err;
    }
  }, [shotId, loadPositions]);

  // Add new item with positions
  const addItem = useCallback(async (
    generationId: string, 
    options: {
      position?: number;
      timelineFrame?: number;
      metadata?: Partial<PositionMetadata>;
    } = {}
  ) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping add item - no shot ID provided');
      return;
    }

    const { position, timelineFrame, metadata } = options;
    
    // Calculate next available positions if not provided
    const nextPosition = position ?? Math.max(...shotGenerations.map(sg => sg.position), -1) + 1;
    const nextFrame = timelineFrame ?? (nextPosition * DEFAULT_FRAME_SPACING);

    console.log('[useEnhancedShotPositions] Adding item:', {
      shotId,
      generationId: generationId.substring(0, 8),
      position: nextPosition,
      timelineFrame: nextFrame
    });

    try {
      const { error } = await supabase
        .from('shot_generations')
        .insert({
          shot_id: shotId,
          generation_id: generationId,
          position: nextPosition,
          timeline_frame: nextFrame,
          metadata: {
            created_by_mode: 'batch',
            frame_spacing: DEFAULT_FRAME_SPACING,
            ...metadata
          }
        });

      if (error) throw error;

      // Reload positions to reflect changes
      await loadPositions();
      
      // Item addition completed successfully - no toast needed for smooth UX
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to add item';
      console.error('[useEnhancedShotPositions] Add error:', err);
      toast.error(`Failed to add item: ${errorMessage}`);
      throw err;
    }
  }, [shotId, shotGenerations, loadPositions]);

  // Update timeline frame for specific item
  const updateTimelineFrame = useCallback(async (
    generationId: string, 
    newTimelineFrame: number,
    metadata?: Partial<PositionMetadata>
  ) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping timeline frame update - no shot ID provided');
      return;
    }

    // Get current state for logging
    const currentItem = shotGenerations.find(sg => sg.generation_id === generationId);
    const beforeFrame = currentItem?.timeline_frame;

    console.log('[PositionResetDebug] üéØ STARTING frame update:', {
      shotId: shotId.substring(0, 8),
      itemId: generationId.substring(0, 8),
      fromFrame: beforeFrame,
      toFrame: newTimelineFrame,
      metadata,
      timestamp: new Date().toISOString(),
      stackTrace: new Error().stack?.split('\n').slice(1, 4)
    });

    setIsPersistingPositions(true);
    try {
      const { error } = await supabase
        .from('shot_generations')
        .update({ 
          timeline_frame: newTimelineFrame,
          metadata: metadata ? { ...metadata } : undefined,
          updated_at: new Date().toISOString()
        })
        .eq('shot_id', shotId)
        .eq('generation_id', generationId);

      if (error) throw error;

      // Optimistically update local state
      setShotGenerations(prev => {
        const updated = prev.map(sg =>
          sg.generation_id === generationId
            ? { ...sg, timeline_frame: newTimelineFrame, metadata: { ...sg.metadata, ...metadata } }
            : sg
        );

        console.log('[TimelineFrameUpdate] ‚úÖ Optimistic update completed:', {
          itemId: generationId.substring(0, 8),
          newFrame: newTimelineFrame,
          totalItems: updated.length
        });

        return updated;
      });
    } catch (error) {
      console.error('[TimelineFrameUpdate] ‚ùå Update failed:', error);
      toast.error('Failed to update timeline position');
      throw error;
    }
  }, [shotId, queryClient]);

  // Update pair prompt for a generation
  const updatePairPrompt = useCallback(async (
    shotId: string,
    generationId: string,
    pairPrompt?: string | null,
    pairNegativePrompt?: string | null
  ) => {
    try {
      console.log('[PairPromptUpdate] üîÑ Updating pair prompt:', {
        shotId: shotId.substring(0, 8),
        generationId: generationId.substring(0, 8),
        pairPrompt: pairPrompt ? '[SET]' : '[NULL]',
        pairNegativePrompt: pairNegativePrompt ? '[SET]' : '[NULL]'
      });

      const { error } = await supabase
        .from('shot_generations')
        .update({
          pair_prompt: pairPrompt && pairPrompt.trim() ? pairPrompt.trim() : null,
          pair_negative_prompt: pairNegativePrompt && pairNegativePrompt.trim() ? pairNegativePrompt.trim() : null,
          updated_at: new Date().toISOString()
        })
        .eq('shot_id', shotId)
        .eq('generation_id', generationId);

      if (error) throw error;

      // Optimistically update local state
      setShotGenerations(prev => {
        const updated = prev.map(sg =>
          sg.generation_id === generationId
            ? {
                ...sg,
                pair_prompt: pairPrompt && pairPrompt.trim() ? pairPrompt.trim() : null,
                pair_negative_prompt: pairNegativePrompt && pairNegativePrompt.trim() ? pairNegativePrompt.trim() : null
              }
            : sg
        );

        console.log('[PairPromptUpdate] ‚úÖ Optimistic update completed:', {
          itemId: generationId.substring(0, 8),
          pairPrompt: pairPrompt ? '[SET]' : '[NULL]',
          pairNegativePrompt: pairNegativePrompt ? '[SET]' : '[NULL]'
        });

        return updated;
      });
    } catch (error) {
      console.error('[PairPromptUpdate] ‚ùå Update failed:', error);
      toast.error('Failed to update pair prompt');
      throw error;
    }
  }, [shotId, queryClient]);

  // Clear all pair prompts for a shot
  const clearAllPairPrompts = useCallback(async (shotId: string) => {
    try {
      console.log('[PairPromptClear] üîÑ Clearing all pair prompts:', {
        shotId: shotId.substring(0, 8)
      });

      const { error } = await supabase
        .from('shot_generations')
        .update({
          pair_prompt: null,
          pair_negative_prompt: null,
          updated_at: new Date().toISOString()
        })
        .eq('shot_id', shotId);

      if (error) throw error;

      // Optimistically update local state
      setShotGenerations(prev => {
        const updated = prev.map(sg => ({
          ...sg,
          pair_prompt: null,
          pair_negative_prompt: null
        }));

        console.log('[PairPromptClear] ‚úÖ All pair prompts cleared:', {
          shotId: shotId.substring(0, 8),
          totalItems: updated.length
        });

        return updated;
      });
    } catch (error) {
      console.error('[PairPromptClear] ‚ùå Clear failed:', error);
      toast.error('Failed to clear pair prompts');
      throw error;
    }
  }, [shotId, queryClient]);

  return {
    shotGenerations,
    isLoading,
    error,
    loadPositions,
    updateTimelineFrame,
    updatePairPrompt,
    clearAllPairPrompts,
    // ... other existing functions
  };
          toFrame: newTimelineFrame,
          beforeCount: prev.length,
          afterCount: updated.length,
          timestamp: new Date().toISOString()
        });
        
        return updated;
      });

      console.log('[PositionResetDebug] ‚úÖ COMPLETED frame update:', {
        shotId: shotId.substring(0, 8),
        itemId: generationId.substring(0, 8),
        fromFrame: beforeFrame,
        toFrame: newTimelineFrame,
        updateVerified: true,
        timestamp: new Date().toISOString()
      });
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update timeline frame';
      console.error('[PositionSystemDebug] ‚ùå FAILED frame update:', {
        shotId: shotId.substring(0, 8),
        itemId: generationId.substring(0, 8),
        fromFrame: beforeFrame,
        toFrame: newTimelineFrame,
        error: errorMessage,
        timestamp: new Date().toISOString()
      });
      toast.error(`Failed to update timeline position: ${errorMessage}`);
      throw err;
    } finally {
      setIsPersistingPositions(false);
    }
  }, [shotId, shotGenerations]);

  // Initialize timeline frames for existing records without them
  const initializeTimelineFrames = useCallback(async (frameSpacing: number = DEFAULT_FRAME_SPACING) => {
    if (!shotId) {
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping timeline initialization - no shot ID provided');
      return;
    }

    // Count items that need initialization
    const itemsNeedingFrames = shotGenerations.filter(sg => sg.timeline_frame === null || sg.timeline_frame === undefined);
    
    console.log('[PositionSystemDebug] üöÄ STARTING timeline initialization:', {
      shotId: shotId.substring(0, 8),
      totalItems: shotGenerations.length,
      itemsNeedingFrames: itemsNeedingFrames.length,
      frameSpacing,
      itemsToInitialize: itemsNeedingFrames.map(sg => ({
        id: sg.generation_id.substring(0, 8),
        currentPosition: sg.position,
        calculatedFrame: 'max_existing_frame + 50 (database function handles this)'
      })),
      timestamp: new Date().toISOString()
    });

    if (itemsNeedingFrames.length === 0) {
      console.log('[PositionSystemDebug] ‚úÖ No initialization needed - all items have timeline frames');
      return 0;
    }

    try {
      const { data, error } = await supabase.rpc('initialize_timeline_frames_for_shot', {
        p_shot_id: shotId,
        p_frame_spacing: frameSpacing
      });

      if (error) throw error;

      const recordCount = data as number;
      
      if (recordCount > 0) {
        await loadPositions({ reason: 'reorder' });
        
        console.log('[PositionSystemDebug] ‚úÖ COMPLETED timeline initialization:', {
          shotId: shotId.substring(0, 8),
          recordsInitialized: recordCount,
          frameSpacing,
          timestamp: new Date().toISOString()
        });
        
        // Timeline frames initialized successfully - no toast needed for smooth UX
      } else {
        console.log('[PositionSystemDebug] ‚ö†Ô∏è No records were initialized (possibly already initialized)');
      }
      
      return recordCount;
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to initialize timeline frames';
      console.error('[PositionSystemDebug] ‚ùå FAILED timeline initialization:', {
        shotId: shotId.substring(0, 8),
        itemsNeedingFrames: itemsNeedingFrames.length,
        error: errorMessage,
        timestamp: new Date().toISOString()
      });
      toast.error(`Failed to initialize timeline frames: ${errorMessage}`);
      throw err;
    }
  }, [shotId, shotGenerations, loadPositions]);

  // Apply timeline frame changes atomically - replaces complex client-side exchange logic
  const applyTimelineFrames = useCallback(async (
    changes: Array<{ generationId: string; timelineFrame: number }>,
    updatePositions: boolean = true
  ) => {
    console.log('[TimelineMoveFlow] üì• HOOK CALLED - applyTimelineFrames received:', {
      shotId: shotId?.substring(0, 8) || 'none',
      changesCount: changes.length,
      changes: changes.map(c => ({
        generationId: c.generationId.substring(0, 8),
        timelineFrame: c.timelineFrame
      })),
      updatePositions
    });
    
    if (!shotId) {
      console.warn('[TimelineMoveFlow] ‚ùå NO SHOT ID - Skipping timeline frame application');
      console.warn('[PositionSystemDebug] ‚ö†Ô∏è Skipping timeline frame application - no shot ID provided');
      return;
    }

    if (changes.length === 0) {
      console.log('[TimelineMoveFlow] ‚úÖ NO CHANGES - Empty changes array');
      console.log('[PositionSystemDebug] ‚ö†Ô∏è No changes to apply');
      return;
    }

    // Log the operation for debugging
    console.log('[PositionSystemDebug] üéØ STARTING atomic timeline frame application:', {
      shotId: shotId.substring(0, 8),
      changesCount: changes.length,
      updatePositions,
      changes: changes.map(c => ({
        id: c.generationId.substring(0, 8),
        frame: c.timelineFrame
      })),
      timestamp: new Date().toISOString(),
      stackTrace: new Error().stack?.split('\n').slice(1, 4)
    });

    setIsPersistingPositions(true);
    
    try {
      // Convert to the format expected by the RPC function
      const rpcChanges = changes.map(c => ({
        generation_id: c.generationId,
        timeline_frame: c.timelineFrame
      }));

        console.log('[TimelineMoveFlow] üì° CALLING SUPABASE RPC - timeline_sync_bulletproof:', {
        shotId: shotId.substring(0, 8),
        rpcChanges: rpcChanges.map(c => ({
          generation_id: c.generation_id.substring(0, 8),
          timeline_frame: c.timeline_frame
        })),
        updatePositions
      });
      
      console.log('[TimelineMoveFlow] üì° FULL RPC PAYLOAD:');
      console.log('p_shot_id:', shotId);
      console.log('p_changes:', rpcChanges);
      console.log('p_update_positions:', updatePositions);

      // Call the BULLETPROOF function (NO ambiguous columns AT ALL)
      console.log('[TimelineMoveFlow] üö® ABOUT TO CALL FUNCTION:', 'timeline_sync_bulletproof');
      console.log('[TimelineMoveFlow] üö® FUNCTION PARAMETERS:', {
        shot_uuid: shotId,
        frame_changes: rpcChanges,
        should_update_positions: updatePositions
      });
      
      const { data, error } = await supabase.rpc('timeline_sync_bulletproof', {
        shot_uuid: shotId,
        frame_changes: rpcChanges,
        should_update_positions: updatePositions
      });

      console.log('[TimelineMoveFlow] üì° SUPABASE RPC RESPONSE:', {
        shotId: shotId.substring(0, 8),
        hasError: !!error,
        error: error?.message || null,
        errorCode: error?.code || null,
        dataLength: data ? (Array.isArray(data) ? data.length : 'not-array') : 'no-data'
      });

      if (error) {
        console.error('‚ùå SUPABASE RPC ERROR - timeline_sync_bulletproof FAILED');
        console.error('[TimelineMoveFlow] üö® ERROR MESSAGE:', error.message);
        console.error('[TimelineMoveFlow] üö® ERROR CODE:', error.code);  
        console.error('[TimelineMoveFlow] üö® ERROR DETAILS:', error.details);
        console.error('[TimelineMoveFlow] üö® ERROR HINT:', error.hint);
        console.error('[TimelineMoveFlow] üö® FULL ERROR JSON:', JSON.stringify(error, null, 2));
        
        // Add timestamp to identify which version of the function is running
        console.error('[TimelineMoveFlow] üïê ERROR TIMESTAMP:', new Date().toISOString());
        console.error('[TimelineMoveFlow] üîç FUNCTION VERSION CHECK - If you see "ambiguous column" error, the old function is still cached');
        
        throw error;
      }

      // Optimistically update local state with the returned data
      if (data && Array.isArray(data)) {
        setShotGenerations(prev => {
          console.log('[Position0JumpBug] üîç BEFORE SERVER UPDATE:', {
            shotId: shotId.substring(0, 8),
            totalItems: prev.length
          });
          const beforeState = prev.map(sg => ({ 
            id: sg.generation_id.substring(0, 8), 
            pos: sg.position, 
            frame: sg.timeline_frame 
          }));
          console.log('[Position0JumpBug] üîç CURRENT STATE DETAILS:');
          beforeState.forEach((item, idx) => {
            console.log(`  ${idx}: id=${item.id}, pos=${item.pos}, frame=${item.frame}`);
          });

          const updatedMap = new Map(prev.map(sg => [sg.generation_id, sg]));
          
          // Update with returned data
          data.forEach((updatedRow: any) => {
            const existing = updatedMap.get(updatedRow.generation_id);
            if (existing) {
              // Log position changes, especially for position 0
              if (existing.position !== updatedRow.position) {
                console.log('[Position0JumpBug] üìä POSITION CHANGE:', {
                  itemId: updatedRow.generation_id.substring(0, 8),
                  oldPos: existing.position,
                  newPos: updatedRow.position,
                  oldFrame: existing.timeline_frame,
                  newFrame: updatedRow.timeline_frame,
                  isPosition0: existing.position === 0 || updatedRow.position === 0
                });
              }

              updatedMap.set(updatedRow.generation_id, {
                ...existing,
                position: updatedRow.position,
                timeline_frame: updatedRow.timeline_frame,
                updated_at: updatedRow.updated_at
              });
            }
          });
          
          const updated = Array.from(updatedMap.values());
          
          console.log('[Position0JumpBug] ‚úÖ AFTER SERVER UPDATE:', {
            shotId: shotId.substring(0, 8),
            totalItems: updated.length
          });
          const afterState = updated.map(r => ({ 
            id: r.generation_id.substring(0, 8), 
            pos: r.position, 
            frame: r.timeline_frame 
          }));
          console.log('[Position0JumpBug] ‚úÖ NEW STATE DETAILS:');
          afterState.forEach((item, idx) => {
            console.log(`  ${idx}: id=${item.id}, pos=${item.pos}, frame=${item.frame}`);
          });

          console.log('[TimelineMoveFlow] ‚úÖ LOCAL STATE UPDATED - Optimistic update from RPC response:', {
            shotId: shotId.substring(0, 8),
            updatedCount: data.length,
            beforeCount: prev.length,
            afterCount: updated.length
          });
          
          console.log('[PositionSystemDebug] üîÑ OPTIMISTIC STATE UPDATE from RPC:', {
            shotId: shotId.substring(0, 8),
            updatedCount: data.length,
            beforeCount: prev.length,
            afterCount: updated.length,
            timestamp: new Date().toISOString()
          });
          
          return updated;
        });
      }

      console.log('[TimelineMoveFlow] üéâ HOOK COMPLETED - applyTimelineFrames finished successfully:', {
        shotId: shotId.substring(0, 8),
        changesApplied: changes.length,
        updatePositions
      });

      console.log('[PositionSystemDebug] ‚úÖ COMPLETED atomic timeline frame application:', {
        shotId: shotId.substring(0, 8),
        changesApplied: changes.length,
        updatePositions,
        timestamp: new Date().toISOString()
      });

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to apply timeline frames';
      
      console.error('[TimelineMoveFlow] ‚ùå HOOK FAILED - applyTimelineFrames error:', {
        shotId: shotId.substring(0, 8),
        changesCount: changes.length,
        error: errorMessage,
        stackTrace: err instanceof Error ? err.stack : undefined
      });
      
      console.error('[PositionSystemDebug] ‚ùå FAILED atomic timeline frame application:', {
        shotId: shotId.substring(0, 8),
        changesCount: changes.length,
        error: errorMessage,
        fullError: err,
        timestamp: new Date().toISOString()
      });
      toast.error(`Failed to update timeline positions: ${errorMessage}`);
      throw err;
    } finally {
      setIsPersistingPositions(false);
    }
  }, [shotId]);

  return { 
    shotGenerations,
    isLoading,
    error,
    isPersistingPositions,
    setIsPersistingPositions,
    getPositionsForMode,
    getImagesForMode,
    exchangePositions,
    batchExchangePositions,
    deleteItem,
    addItem,
    updateTimelineFrame,
    updatePairPrompt,
    clearAllPairPrompts,
    initializeTimelineFrames,
    applyTimelineFrames,
    loadPositions
  };
};
